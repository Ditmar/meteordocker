{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary:computed-field/lib.js"],"names":["module","export","ComputedField","constructor","func","equalsFunc","dontStop","_","isBoolean","handle","lastValue","autorun","currentView","Package","blaze","Blaze","_isInRender","f","templateInstanceFunc","Template","_currentTemplateInstanceFunc","comp","Tracker","c","_withCurrentView","_withTemplateInstanceFunc","call","stopComputation","stop","onViewDestroyed","onStop","removeViewDestroyedListener","startAutorun","computation","value","ReactiveVar","set","afterFlush","dep","hasDependents","getter","originalStop","flush","get","Object","setPrototypeOf","prototype","__proto__","toString","apply","_isRunning","nonreactive"],"mappings":"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","file":"/packages/peerlibrary_computed-field.js","sourcesContent":["export class ComputedField {\n  constructor(func, equalsFunc, dontStop) {\n    // To support passing boolean as the second argument.\n    if (_.isBoolean(equalsFunc)) {\n      dontStop = equalsFunc;\n      equalsFunc = null;\n    }\n\n    let handle = null;\n    let lastValue = null;\n\n    // TODO: Provide an option to prevent using view's autorun.\n    //       One can wrap code with Blaze._withCurrentView(null, code) to prevent using view's autorun for now.\n    let autorun;\n    const currentView = Package.blaze && Package.blaze.Blaze && Package.blaze.Blaze.currentView\n    if (currentView) {\n      if (currentView._isInRender) {\n        // Inside render we cannot use currentView.autorun directly, so we use our own version of it.\n        // This allows computed fields to be created inside Blaze template helpers, which are called\n        // the first time inside render. While currentView.autorun is disallowed inside render because\n        // autorun would be recreated for reach re-render, this is exactly what computed field does\n        // anyway so it is OK for use to use autorun in this way.\n        autorun = function (f) {\n          const templateInstanceFunc = Package.blaze.Blaze.Template._currentTemplateInstanceFunc;\n\n          const comp = Tracker.autorun((c) => {\n            Package.blaze.Blaze._withCurrentView(currentView, () => {\n              Package.blaze.Blaze.Template._withTemplateInstanceFunc(templateInstanceFunc, () => {\n                f.call(currentView, c);\n              })\n            });\n          });\n\n          const stopComputation = () => {\n            comp.stop();\n          };\n          currentView.onViewDestroyed(stopComputation);\n          comp.onStop(() => {\n            currentView.removeViewDestroyedListener(stopComputation);\n          });\n\n          return comp;\n        };\n\n      }\n      else {\n        autorun = (f) => {\n          return currentView.autorun(f);\n        }\n      }\n    }\n    else {\n      autorun = Tracker.autorun;\n    }\n\n    const startAutorun = function () {\n      handle = autorun(function (computation) {\n        const value = func();\n\n        if (!lastValue) {\n          lastValue = new ReactiveVar(value, equalsFunc);\n        }\n        else {\n          lastValue.set(value);\n        }\n\n        if (!dontStop) {\n          Tracker.afterFlush(function () {\n            // If there are no dependents anymore, stop the autorun. We will run\n            // it again in the getter's flush call if needed.\n            if (!lastValue.dep.hasDependents()) {\n              getter.stop();\n            }\n          });\n        }\n      });\n\n      // If something stops our autorun from the outside, we want to know that and update internal state accordingly.\n      // This means that if computed field was created inside an autorun, and that autorun is invalided our autorun is\n      // stopped. But then computed field might be still around and it might be asked again for the value. We want to\n      // restart our autorun in that case. Instead of trying to recompute the stopped autorun.\n      if (handle.onStop) {\n        handle.onStop(() => {\n          handle = null;\n        });\n      }\n      else {\n        // XXX COMPAT WITH METEOR 1.1.0\n        const originalStop = handle.stop;\n        handle.stop = function () {\n          if (handle) {\n            originalStop.call(handle);\n          }\n          handle = null;\n        };\n      }\n    };\n\n    startAutorun();\n\n    const getter = function () {\n      // We always flush so that you get the most recent value. This is a noop if autorun was not invalidated.\n      getter.flush();\n      return lastValue.get();\n    };\n\n    // We mingle the prototype so that getter instanceof ComputedField is true.\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(getter, this.constructor.prototype);\n    }\n    else {\n      getter.__proto__ = this.constructor.prototype;\n    }\n\n    getter.toString = function() {\n      return `ComputedField{${this()}}`;\n    };\n\n    getter.apply = () => {\n      return getter();\n    };\n\n    getter.call = () => {\n      return getter();\n    };\n\n    // If this autorun is nested in the outside autorun it gets stopped automatically when the outside autorun gets\n    // invalidated, so no need to call destroy. But otherwise you should call destroy when the field is not needed anymore.\n    getter.stop = function () {\n      if (handle != null) {\n        handle.stop();\n      }\n      return handle = null;\n    };\n\n    // For tests.\n    getter._isRunning = () => {\n      return !!handle;\n    };\n\n    // Sometimes you want to force recomputation of the new value before the global Tracker flush is done.\n    // This is a noop if autorun was not invalidated.\n    getter.flush = () => {\n      Tracker.nonreactive(function () {\n        if (handle) {\n          handle.flush();\n        }\n        else {\n          // If there is no autorun, create it now. This will do initial recomputation as well. If there\n          // will be no dependents after the global flush, autorun will stop (again).\n          startAutorun();\n        }\n      })\n    };\n\n    return getter;\n  }\n}\n"]}